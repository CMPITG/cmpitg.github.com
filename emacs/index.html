<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hướng dẫn Emacs</title>
    <meta name="author" content="Ha-Duong Nguyen" />
    <meta name="description" content="thoughts & rants on tech & language, by cmpitg" />
    <link rel="canonical" href="http://reference-error.org//emacs/" />
    <!-- <link href="//fonts.googleapis.com/css?family=Nunito:400,700,300|Varela+Round" rel="stylesheet" type="text/css"> -->
    <link href="//fonts.googleapis.com/css?family=Alegreya+Sans|Ubuntu+Mono" rel="stylesheet">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="alternate" type="application/rss+xml" title="Reference Error" href="/atom.xml" />
    <link rel="stylesheet" href="/css/site.css">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      
        ga('create', ', 'auto');
        ga('send', 'pageview');
    </script>
  </head>
  <body>
    <section>
      <header class="navigation">
        <div id="header-title">
          <a href="/" class="logo" title="Reference Error">
            Reference Error
      </a>
        </div>
        <div id="social-links-header">
          <a title="cmpitg @ github" href="https://github.com/cmpitg"><i class="fa fa-github-square"></i></a>
          <a title="cmpitg @ linkedin" href="https://fi.linkedin.com/in/cmpitg"><i class="fa fa-linkedin-square"></i></a>
          <a title="cmpitg @ twitter" href="https://twitter.com/cmpitg"><i class="fa fa-twitter-square"></i></a>
        </div>
        <nav>
          <ul>
            <li><a href="/logs">logs</a></li>
            <li><a href="/writing">writing</a></li>
            <li><a href="/talks">talks</a></li>
            <li><a href="/about">about</a></li>
            <li class="no-bullet"><a href="/atom.xml">rss</a></li>
          </ul>
        </nav>
      </header>
      <article>
        <h1 class="title">
          Hướng dẫn Emacs
  </h1>
        <p class="subtitle">
          <span>
            Series:
          
            
              <a href="/#emacs">emacs</a>,
            
          
            
              <a href="/#guide">guide</a>
          </span>
          <span class="date">
          </span>
        </p>
        <div id="post">
          <p><strong>Phiên bản hỗ trợ:</strong> <a href="http://www.gnu.org/software/emacs/">GNU Emacs</a> 24+</p>
          <h2 id="cc-khi-nim">Các khái niệm</h2>
          <ul>
            <li>Emacs là một loại trình soạn thảo văn bản thô (plain text editor) và hơn thế
nữa</li>
            <li>GNU Emacs là một implementation của Emacs</li>
            <li>Emacs Lisp là ngôn ngữ được sử dụng để lập trình (cùng với C) và tùy biến
Emacs</li>
          </ul>
          <h2 id="lu-">Lưu ý</h2>
          <p>Emacs Lisp là một
            <a href="http://emacswiki.org/emacs/WhyDoesElispSuck">ngôn ngữ rất tồi tệ</a>.  Tuy nhiên
luôn có cách thức để sử dụng bất kỳ một dialect của
            <a href="http://en.wikipedia.org/wiki/Lisp_programming_language">Lisp</a> một cách
            <a href="http://www.paulgraham.com/onlisptext.html">đẹp đẽ</a>.  Điểm khác biệt giữa Lisp
và các ngôn ngữ khác này nói một cách ngắn gọn:</p>
          <ul>
            <li>
              <p>Mức độ mô tả chương trình của <em>hầu hết</em> các ngôn ngữ non-Lisp đều bị giới
hạn bởi cú pháp.  Do đó khi giải quyết một bài toán, người giải luôn phải
phân tích bài toán xuống mức độ chi tiết cần thiết, thậm chí đưa vào những
thông tin làm <em>xấu</em> lời giải mới có thể lập trình được.</p>
            </li>
            <li>
              <p><a href="http://www.paulgraham.com/lisp.html">Các tính năng của Lisp</a> giúp Lisp trở
thành một loại ngôn ngữ “tự lập trình chính nó” (programmable programming
language).  Người viết chương trình bằng Lisp không những không cần thêm
những bước chi tiết hóa không cần thiết mà còn có thể <em>biến đổi Lisp</em> để
Lisp phù hợp với vấn đề cần được giải.  Đọc thêm
                <a href="http://www.paulgraham.com/onlisptext.html">On Lisp</a> của
                <a href="http://www.paulgraham.com">Paul Graham</a> để biết thêm chi tiết.</p>
            </li>
          </ul>
          <p>Tuy nhiên, trong hàng trăm loại Lisp dialect, tôi thấy có</p>
          <ul>
            <li><a href="http://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme</a> (và các dialect của Scheme)</li>
            <li><a href="http://en.wikipedia.org/wiki/Racket_%28programming_language%29">Racket</a></li>
            <li><a href="http://en.wikipedia.org/wiki/Clojure">Clojure</a></li>
            <li><a href="http://en.wikipedia.org/wiki/Arc_%28programming_language%29">Arc Lisp</a></li>
            <li><a href="http://en.wikipedia.org/wiki/Picolisp">PicoLisp</a></li>
          </ul>
          <p>là <em>đẹp đẽ</em>.  Các Lisp khác (đặc biệt là Common Lisp và Emacs Lisp) đều gặp
phải vấn đề liên quan đến thiết kế ngôn ngữ, rất dễ để viết mã không trong
sáng và rất khó để viết mã đẹp.  Giá kể
            <a href="http://en.wikipedia.org/wiki/Newlisp">newLISP</a> được thiết kế khéo hơn một
chút (hỗ trợ cấu trúc dữ liệu kiểu hashtable-like, paradigm rõ ràng, …) thì
newLISP cũng là một Lisp đẹp.</p>
          <p>Trang này sẽ liệt kê các kỹ thuật giúp các bạn dùng và tùy biến Emacs tốt hơn.</p>
          <h2 id="t-duy-khi-vit-emacs-lisp">Tư duy khi viết Emacs Lisp</h2>
          <ul>
            <li>API mặc định của Emacs Lisp rất tồi tệ và khó hiểu.  Chẳng hạn:
    
              <ul>
                <li>Khi muốn <em>mở tệp</em>, bạn phải dùng hàm <code class="highlighter-rouge">find-file</code>.  Ồ, tôi có muốn tìm tệp
đâu mà lại bảo tôi dùng <code class="highlighter-rouge">find</code>?</li>
                <li>Các hàm trả lại giá trị <code class="highlighter-rouge">t</code> hoặc <code class="highlighter-rouge">f</code> (<code class="highlighter-rouge">true</code>/<code class="highlighter-rouge">false</code>) lúc thì máy móc theo
Common Lisp convention với hậu tố <code class="highlighter-rouge">-p</code>, lúc thì lại không.  Trong khi đó
dấu <code class="highlighter-rouge">?</code> đẹp và dễ hiểu thế thì lại không dùng. So sánh: <code class="highlighter-rouge">installed-p</code> với
                  <code class="highlighter-rouge">installed?</code> hoặc <code class="highlighter-rouge">is-installed?</code></li>
              </ul>
            </li>
            <li>Các hàm tự định nghĩa nên:
    
              <ul>
                <li>Đặt tên thật dễ hiểu</li>
                <li>Mỗi hàm làm đúng một công việc duy nhất</li>
                <li>Có documentation chi tiết</li>
                <li>Có ký tự riêng để tránh tranh chấp với tên sẵn có (built-in hoặc do gói
khác định nghĩa).  Chẳng hạn tất cả các nên do tôi đặt đều có <code class="highlighter-rouge">$</code> làm tiền
tố.</li>
              </ul>
            </li>
          </ul>
          <h2 id="emacs-package-manager">Emacs Package Manager</h2>
          <p>Emacs package manager là tính năng quản lý gói của Emacs, có sẵn từ Emacs 24 trở đi.</p>
          <ul>
            <li>Xác định xem một gói đã được cài hay chưa: Dùng hàm <code class="highlighter-rouge">(package-installed-p
package-name)</code>.  Tôi thì lại thích đặt alias thành <code class="highlighter-rouge">($package-installed?
package-name)</code>.</li>
          </ul>
          <h2 id="cc-vn--gp-phi-khi-s-dng-emacs">Các vấn đề gặp phải khi sử dụng Emacs</h2>
          <h3 id="li-helm-symbols-function-definition-is-void-helm-log-eval-internal">Lỗi Helm: <code class="highlighter-rouge">Symbol's function definition is void: helm-log-eval-internal</code></h3>
          <p>Theo cách xử lý
            <a href="https://github.com/emacs-helm/helm/issues/354">issue đã được report trên Github</a>:
chuyển đến thư mục của Helm (thông thường là <code class="highlighter-rouge">~/.emacs.d/elpa/helm-[version]</code>
            nếu bạn cài Helm từ ELPA), chạy <code class="highlighter-rouge">make</code> lại hoặc xóa hết các file <code class="highlighter-rouge">.elc</code> và
load lại <code class="highlighter-rouge">helm.el</code> là được:</p>
          <div class="highlighter-rouge">
            <pre class="highlight"><code># M-x eshell
cd ~/.emacs.d/elpa/helm-*/
rm -rf *.elc
load helm.el
</code></pre>
          </div>
          <h2 id="cc-k-thut">Các kỹ thuật</h2>
          <p>Cách tốt nhất để bắt đầu là đọc các hướng dẫn tuyệt vời và cẩn thận của
            <a href="http://xahlee.org/">Xah Lee</a>:</p>
          <ul>
            <li><a href="http://ergoemacs.org/emacs/elisp_basics.html">Emacs Lisp Tutorial by Example</a></li>
            <li><a href="http://ergoemacs.org/emacs/elisp_common_functions.html">Common Emacs Lisp Functions</a></li>
            <li><a href="http://ergoemacs.org/emacs/elisp_idioms_batch.html">Emacs Lisp Idioms for Text_Editor Processing in Batch Style</a></li>
            <li><a href="http://ergoemacs.org/emacs/elisp_idioms.html">Emacs Lisp Idioms for Writing Interactive Commands</a></li>
          </ul>
          <p>Khi cấu hình một thư viện, cách tốt nhất là đặt code cấu hình trong
            <code class="highlighter-rouge">eval-after-load</code> để đảm bảo Emacs vẫn chạy ngay cả khi thư viện ấy chưa được
cài đặt.  Chẳng hạn để kích hoạt <code class="highlighter-rouge">eldoc-mode</code> trong các mode liên quan đến
Lisp:</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">eval-after-load</span> <span class="ss">'eldoc</span>
  <span class="o">'</span><span class="p">(</span><span class="nf">progn</span>
     <span class="p">(</span><span class="nf">add-hook</span> <span class="ss">'emacs-lisp-mode-hook</span>        <span class="ss">'turn-on-eldoc-mode</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">add-hook</span> <span class="ss">'lisp-interaction-mode-hook</span>  <span class="ss">'turn-on-eldoc-mode</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">add-hook</span> <span class="ss">'ielm-mode-hook</span>              <span class="ss">'turn-on-eldoc-mode</span><span class="p">)))</span>
</code></pre>
          </div>
          <h3 id="s-dng-c-u-v-gi-command-khi-vit-emacs-lisp">Sử dụng <code class="highlighter-rouge">C-u</code> và gọi command khi viết Emacs Lisp</h3>
          <p>Về bản chất, <code class="highlighter-rouge">C-u</code> gọi hàm <code class="highlighter-rouge">universal-argument</code>, hàm này sẽ đặt giá trị
            <code class="highlighter-rouge">current-prefix-arg</code> bằng số lần nhấn <code class="highlighter-rouge">C-u</code> sử dụng
            <a href="http://en.wikipedia.org/wiki/Dynamic_binding">dynamic binding</a> và trả lại giá
trị <code class="highlighter-rouge">nil</code> sau khi command được thực hiện xong.  Do đó, để viết Emacs Lisp thực
hiện lại quá trình này, mã nguồn sẽ có dạng sau:</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">current-prefix-arg</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">call-interactively</span> <span class="ss">'some-function</span><span class="p">))</span>
</code></pre>
          </div>
          <h3 id="lun-s-dng-sunrise-commander-thay-cho-dired">Luôn sử dụng Sunrise Commander thay cho Dired</h3>
          <p>Có thể bạn chưa biết,
            <a href="http://www.emacswiki.org/emacs/Sunrise_Commander">Sunrise Commander</a> là một
file browser rất tuyệt cho Emacs.  Tuy nhiên, người dùng Sunrise có thể gặp
vấn đề: khi chuyển thư mục với <code class="highlighter-rouge">j</code>, mode tự động nhảy sang Dired rất phiền
toái.  Tính năng của Sunrise hoàn toàn có thể thay thế Dired và hơn thế nữa.
Để thay thế Dired bằng Sunrise khi mở thư mục thông thường, dùng:</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">setq-default</span> <span class="nv">find-directory-functions</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">'sr-dired</span> <span class="nv">find-directory-functions</span><span class="p">))</span>
</code></pre>
          </div>
          <h3 id="kim-tra-du-ngoc-thathiu">Kiểm tra dấu ngoặc thừa/thiếu</h3>
          <p>Sử dụng command/hàm <code class="highlighter-rouge">check-parens</code>.</p>
          <h3 id="chn-header-vo-u-file">Chèn header vào đầu file</h3>
          <p>Rất thuận tiện, đặt biệt khi tạo một thư viện Emacs Lisp.  Dùng command/hàm
            <code class="highlighter-rouge">auto-insert</code> để đạt được điều này.</p>
          <h3 id="to-global-mode-cho-mt-minor-mode">Tạo global mode cho một minor mode</h3>
          <p>Sử dụng <code class="highlighter-rouge">define-globalized-minor-mode</code>.  Chẳng hạn với
            <a href="https://github.com/capitaomorte/autopair"><code class="highlighter-rouge">autopair</code></a>, global mode được tạo
như sau:</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">define-globalized-minor-mode</span>
  <span class="nv">autopair-global-mode</span> <span class="nv">autopair-mode</span> <span class="nv">autopair-on</span><span class="p">)</span>
</code></pre>
          </div>
          <p><code class="highlighter-rouge">autopair-on</code> là hàm không nhận tham số, được gọi khi mode được kích hoạt.
Tham khảo trong documentation của <code class="highlighter-rouge">define-globalized-minor-mode</code> để biết thêm
chi tiết.</p>
          <h3 id="t-docstring-cho-hm-ca-emacs-lisp">Đặt docstring cho hàm của Emacs Lisp</h3>
          <p>Theo
            <a href="http://nullprogram.com/blog/2012/08/02/">entry “Programmatically Setting Lisp Docstrings”</a>.</p>
          <p>Thông thường, một hàm Emacs Lisp sẽ nhận tham số <code class="highlighter-rouge">docstring</code> ngay sau khi danh
sách tham số được khai báo:</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">defun</span> <span class="nv">this-is-a-dummy-function</span> <span class="p">(</span><span class="nf">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="s">"And this is its docstring."</span>
  <span class="nv">nil</span><span class="p">)</span>
</code></pre>
          </div>
          <p>Docstring <em>của một hàm</em> được lưu trong thuộc tính <code class="highlighter-rouge">function-documentation</code> của
symbol tên hàm đó.  Docstring <em>của một hàm</em> có thể được truy cập với hàm
            <code class="highlighter-rouge">documentation</code>.</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">documentation</span> <span class="ss">'this-is-a-dummy-function</span><span class="p">)</span>
<span class="c1">;; =&gt; And this is its docstring.</span>

<span class="p">(</span><span class="nf">documentation</span> <span class="ss">'format</span><span class="p">)</span>
<span class="c1">;; =&gt; ...</span>
</code></pre>
          </div>
          <p>Để đặt lại docstring cho một hàm, ta chỉ việc đặt lại thuộc tính
            <code class="highlighter-rouge">function-documentation</code> của symbol tên hàm.</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">put</span> <span class="ss">'this-is-a-dummy-function</span> <span class="ss">'function-documentation</span>
  <span class="s">"Hola mundo."</span><span class="p">)</span>
<span class="p">(</span><span class="nf">documentation</span> <span class="ss">'this-is-a-dummy-function</span><span class="p">)</span>    <span class="c1">;; =&gt; Hola mundo.</span>
</code></pre>
          </div>
          <p>Tuy nhiên cần chú ý: sau khi đặt docstring sử dụng <code class="highlighter-rouge">put</code>, mỗi lần khai báo lại
hàm cần đặt lại docstring bằng <code class="highlighter-rouge">put</code> hoặc dùng</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">put</span> <span class="ss">'name-of-the-function</span> <span class="ss">'function-documentation</span> <span class="nv">nil</span><span class="p">)</span>
</code></pre>
          </div>
          <p>thì docstring mới mới có hiệu lực.</p>
          <h3 id="b-tnh-nng-t-ng-nhy-vo-th-mc-ca-helm-find-files">Bỏ tính năng tự động nhảy vào thư mục của <code class="highlighter-rouge">helm-find-files</code></h3>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">setq-default</span> <span class="nv">helm-ff-auto-update-initial-value</span> <span class="nv">nil</span><span class="p">)</span>
</code></pre>
          </div>
          <h3 id="remap-li-key-da-trn-tn-function">Remap lại key dựa trên tên function</h3>
          <p>Theo
            <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Remapping-Commands.html">GNU Emacs Lisp Reference</a>:</p>
          <ul>
            <li>
              <p>Khi bạn set:</p>
              <div class="language-scheme highlighter-rouge">
                <pre class="highlight"><code><span class="p">(</span><span class="nf">global-set-key</span> <span class="p">(</span><span class="nf">kbd</span> <span class="s">"C-c"</span><span class="p">)</span> <span class="ss">'a-function</span><span class="p">)</span>
</code></pre>
              </div>
              <p>Điều này tương đương với:</p>
              <div class="language-scheme highlighter-rouge">
                <pre class="highlight"><code><span class="p">(</span><span class="nf">define-key</span> <span class="p">(</span><span class="nf">current-global-map</span><span class="p">)</span> <span class="p">(</span><span class="nf">kbd</span> <span class="s">"C-c"</span><span class="p">)</span> <span class="ss">'a-function</span><span class="p">)</span>
</code></pre>
              </div>
              <p>Nghĩa là bất kỳ keybinding global nào được set bằng <code class="highlighter-rouge">global-set-key</code> cũng có
thể được set bằng <code class="highlighter-rouge">define-key</code>.</p>
            </li>
            <li>
              <p>Để remap key thực hiện function <code class="highlighter-rouge">kill-line</code> sang
function <code class="highlighter-rouge">my-kill-line</code>, dùng:</p>
              <div class="language-scheme highlighter-rouge">
                <pre class="highlight"><code><span class="p">(</span><span class="nf">define-key</span> <span class="nv">some-mode-map</span> <span class="err">[</span><span class="nv">remap</span> <span class="nv">kill-line</span><span class="err">]</span> <span class="ss">'my-kill-line</span><span class="p">)</span>

<span class="c1">;; or with global keybinding</span>
<span class="p">(</span><span class="nf">global-set-key</span> <span class="err">[</span><span class="nv">remap</span> <span class="nv">kill-line</span><span class="err">]</span> <span class="ss">'my-kill-line</span><span class="p">)</span>
</code></pre>
              </div>
            </li>
            <li>
              <p>Remap chỉ hoạt động ở <em>một mức</em>, tức là nếu bạn dùng:</p>
              <div class="language-scheme highlighter-rouge">
                <pre class="highlight"><code><span class="p">(</span><span class="nf">define-key</span> <span class="nv">some-mode-map</span> <span class="err">[</span><span class="nv">remap</span> <span class="nv">kill-line</span><span class="err">]</span> <span class="ss">'my-kill-line</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-key</span> <span class="nv">some-mode-map</span> <span class="err">[</span><span class="nv">remap</span> <span class="nv">my-kill-line</span><span class="err">]</span> <span class="ss">'my-other-kill-line</span><span class="p">)</span>
</code></pre>
              </div>
              <p>Thì dòng remap thứ hai <strong>không có tác dụng</strong>*, nghĩa là <code class="highlighter-rouge">kill-line</code> chỉ được
remap thành <code class="highlighter-rouge">my-kill-line</code>.</p>
            </li>
            <li>
              <p>Để undo một remap, remap lại key thành nil:</p>
              <div class="language-scheme highlighter-rouge">
                <pre class="highlight"><code><span class="p">(</span><span class="nf">define-key</span> <span class="nv">some-mode-map</span> <span class="err">[</span><span class="nv">remap</span> <span class="nv">kill-line</span><span class="err">]</span> <span class="nv">nil</span><span class="p">)</span>
</code></pre>
              </div>
            </li>
          </ul>
          <h3 id="thi-hnh-shell-command-a-output-ra-temp-buffer">Thi hành shell command, đưa output ra temp buffer</h3>
          <p>Tham số thứ hai của <code class="highlighter-rouge">shell-command</code> định rõ output buffer, nếu là <code class="highlighter-rouge">t</code> thì
output sẽ được đưa ra buffer hiện tại:</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">with-temp-buffer</span>
  <span class="p">(</span><span class="nf">shell-command</span> <span class="s">"cat ~/.emacs.d/init.el"</span> <span class="nv">t</span><span class="p">))</span>
</code></pre>
          </div>
          <h3 id="b-nonpane-buffer-ca-s-ph-bn-di-khi-khi-ng-sunrise-commander">Bỏ nonpane buffer (cửa sổ phụ bên dưới) khi khởi động Sunrise Commander</h3>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">defun</span> <span class="nv">sunrise-without-nonpane-buffer</span> <span class="p">()</span>
  <span class="s">"Open Sunrise Commander without the nonpane buffer."</span>
  <span class="p">(</span><span class="nf">unless</span> <span class="nv">sr-running</span>
    <span class="p">(</span><span class="nf">sunrise</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">sr-setup-windows</span><span class="p">)</span>  <span class="c1">; Make sure windows are setup properly</span>
    <span class="p">(</span><span class="nf">windmove-down</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">delete-window</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span> <span class="nv">sunrise-cd-without-nonpane-buffer</span> <span class="p">()</span>
  <span class="s">"Open sunrise-cd without the nonpane buffer."</span>
  <span class="p">(</span><span class="nf">unless</span> <span class="nv">sr-running</span>
    <span class="p">(</span><span class="nf">sunrise-cd</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">sr-setup-windows</span><span class="p">)</span>  <span class="c1">; Make sure windows are setup properly</span>
    <span class="p">(</span><span class="nf">windmove-down</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">delete-window</span><span class="p">)))</span>
</code></pre>
          </div>
          <h3 id="dng-interactive-vi-gi-tr-mc-nh">Dùng <code class="highlighter-rouge">interactive</code> với giá trị mặc định</h3>
          <p>Hiểu cách thức <code class="highlighter-rouge">interactive</code>
            <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Interactive.html">hoạt động</a>.</p>
          <div class="language-scheme highlighter-rouge">
            <pre class="highlight"><code><span class="p">(</span><span class="nf">interactive</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nf">$read-string</span> <span class="s">"File name (~/bin/): "</span>
                           <span class="nv">:initial-input</span> <span class="s">"~/bin/"</span><span class="p">)))</span>
</code></pre>
          </div>
          <h3 id="ng-emacs">Đóng Emacs</h3>
          <p>Sử dụng command/hàm <code class="highlighter-rouge">(kill-emacs)</code> hoặc <code class="highlighter-rouge">(save-buffers-kill-emacs)</code>.</p>
          <h3 id="to-menu">Tạo menu</h3>
          <p>Có 2 loại menu chính cần quan tâm:</p>
          <ul>
            <li>
              <p>Submenu: bản chất là một container, chứa các menu item hoặc các submenu
khác.</p>
            </li>
            <li>
              <p>Menu item: là… menu item.</p>
            </li>
          </ul>
          <p>Trong Emacs thì menu (cả submenu và menu item) về bản chất đều là một
            <em>keybinding</em>, trong đó:</p>
          <ul>
            <li>
              <p><em>Keymap</em> chứa binding này là <em>keymap</em> thuộc về một mode.  Đây là mode mà
menu được hiển thị.</p>
            </li>
            <li>
              <p><em>Key stroke</em> của binding đóng vai trò là ID của menu, có dạng
                <code class="highlighter-rouge">[parent-menu1 parent-menu2 this-menu-id]</code>; key stroke này còn gọi là <em>fake
keybinding</em>.</p>
            </li>
            <li>
              <p><em>Command</em> của binding có dạng:</p>
              <ul>
                <li><code class="highlighter-rouge">'("Menu title" . action)</code> với menu thường và</li>
                <li><code class="highlighter-rouge">'("Menu title" "Tooltip" . action)</code> với menu có tooltip.
Giống với keybinding, <code class="highlighter-rouge">action</code> là một hàm <code class="highlighter-rouge">interactive</code>.</li>
              </ul>
            </li>
          </ul>
          <p>Do vậy, bản chất việc thêm, sửa, xóa menu là các thao tác thêm, sửa, xóa
keymap hoặc keybinding tương ứng.</p>
          <p>Chú ý khi tạo menu:</p>
          <ul>
            <li>
              <p>Với submenu: <code class="highlighter-rouge">make-sparse-keymap</code> cần nhận thêm một string (gọi là <em>overall
prompt string</em>).  String này thường rất ngắn gọn, mô tả mục đích/hoạt động
của submenu.</p>
            </li>
            <li>
              <p><code class="highlighter-rouge">define-key-after</code> thường được dùng thay cho <code class="highlighter-rouge">define-key</code> vì bạn có thể chèn
menu vào vị trí mong muốn.</p>
            </li>
          </ul>
          <p><strong>Ví dụ:</strong></p>
          <ul>
            <li>
              <p>Tạo/sửa một submenu:</p>
              <pre><code class="language-lisp">(define-key-after mode-where-menu-is-visible
                  menu-id
                  `("Submenu" . ,(make-sparse-keymap "Purpose of menu"))))
;; Or
(define-key-after mode-where-menu-is-visible
                  menu-id
                  `("Submenu" "Tooltip" . ,(make-sparse-keymap "Purpose of menu")))
</code></pre>
            </li>
            <li>
              <p>Tạo/sửa một menu item:</p>
              <pre><code class="language-lisp">(define-key-after mode-where-menu-is-visible
                  menu-id
                  '("Menu item" . its-action))
;; Or
(define-key mode-where-menu-is-visible
            menu-id
            '("Menu item" "Tooltip" . its-action))
</code></pre>
            </li>
            <li>
              <p>Xóa một menu:</p>
              <pre><code class="language-lisp">(define-key-after mode-where-menu-is-visible menu-id nil)
</code></pre>
            </li>
          </ul>
          <h3 id="tm-command-tng-ng-vi-mt-key-sequence">Tìm command tương ứng với một key sequence</h3>
          <p>Có 2 hàm giúp làm được điều này:</p>
          <ul>
            <li>
              <p><code class="highlighter-rouge">(key-binding key-sequence)</code> tìm trong tất cả các active keymaps và trả lại
command tương ứng.</p>
            </li>
            <li>
              <p><code class="highlighter-rouge">(lookup-key keymap key-sequence)</code> tìm trong một keymap nào đó.</p>
            </li>
          </ul>
          <p>Chú ý rằng menu về bản chất cũng là keybinding nên 2 hàm này có thể áp dụng
để tìm command cho menu.</p>
          <h3 id="s-dng-keyword-argument-ging-common-lisp">Sử dụng keyword argument giống Common Lisp</h3>
          <p>http://curiousprogrammer.wordpress.com/2009/08/16/elisp-keyword-params/</p>
          <h3 id="chuyn-nhanh-n-mt-th-vin--c-ci-t">Chuyển nhanh đến một thư viện đã được cài đặt</h3>
          <p>Sử dụng command <code class="highlighter-rouge">find-library</code>.</p>
          <h3 id="thm-mt-file-local-variable">Thêm một file local variable</h3>
          <p>Sử dụng command <code class="highlighter-rouge">add-file-local-variable</code>.</p>
        </div>
        <hr class="fin" />
      </article>
      <footer>
        <div id="copyright-footer">© Ha-Duong Nguyen 2016.
    Unless clearly stated, all contents are released under the terms of
    the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC
    BY-SA v4.0 license</a>.</div>
      </footer>
      <div id="fine-print">
        <p>
        </p>
      </div>
    </section>
  </body>
</html>